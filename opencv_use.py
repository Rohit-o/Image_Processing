# -*- coding: utf-8 -*-
"""OpenCV_Use.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wCE-1Zlzm_XSAI0B11dYWChwgjwqhLfY
"""

# 1. Mount Google Drive
from google.colab import drive
drive.mount('/content/drive')

# 2. Change the current working directory to the correct folder
import os

# Use the correct folder path with the exact capitalization and the space
# Python handles spaces in strings just fine when passed to os.chdir
correct_path = '/content/drive/My Drive/Colab Notebooks/ML_C1W2Labs/Files/home/jovyan/work/images'
os.chdir(correct_path)

print(f"Current working directory: {os.getcwd()}")


from PIL import Image
import numpy as np

# Assumes you uploaded 'input_image.png' via the Colab GUI
image_path = 'C1_W2_Lab06_contours.PNG'
img = Image.open(image_path)
img_array = np.array(img)

print("Pixel data snippet (top left 5x5 pixels):")
print(img_array[:5, :5, :])

# Install OpenCV in Colab if you haven't already
!pip install opencv-python

import cv2
import matplotlib.pyplot as plt

# Your existing code to load the image
image_path = 'C1_W2_Lab06_contours.PNG'
img_bgr = cv2.imread(image_path) # OpenCV reads in BGR format
img_rgb = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2RGB) # Convert to RGB for correct display

# 1. Convert to grayscale (contours require a single-channel binary image)
gray = cv2.cvtColor(img_bgr, cv2.COLOR_BGR2GRAY)

# 2. Apply thresholding to get a binary image
# The boundary between black and white pixels becomes the contour boundary
ret, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)

# 3. Find the contours
# RETR_EXTERNAL retrieves only the outer contours of your two diagrams
contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

# 4. Draw the detected contours on the original color image
cv2.drawContours(img_rgb, contours, -1, (0, 255, 0), 2) # Draws in green with thickness 2

# 5. Display the result in Colab
plt.figure(figsize=(10, 10))
plt.imshow(img_rgb)
plt.title(f"Found {len(contours)} contours")
plt.axis('off')
plt.show()

# Install scikit-image and scipy if you haven't already in your Colab cell
!pip install scikit-image scipy

import numpy as np
from PIL import Image
import os
import scipy.ndimage # We use scipy for the specific convolution function

# ... (Your Mount & ChDir code from before) ...
from google.colab import drive
drive.mount('/content/drive')

correct_path = '/content/drive/My Drive/Colab Notebooks/ML_C1W2Labs/Files/home/jovyan/work/images'
os.chdir(correct_path)
print(f"Current working directory: {os.getcwd()}")

image_path = 'C1_W2_Lab06_contours.PNG'
img = Image.open(image_path).convert('L') # Convert to grayscale ('L') for simplicity
img_array = np.array(img)

# --- Create your own custom filter matrix (kernel) ---

# Example 1: A simple sharpening filter
# This matrix emphasizes the difference between a pixel and its neighbors
sharpening_kernel = np.array([
    [ 0, -1,  0],
    [-1,  5, -1],
    [ 0, -1,  0]
])

# Example 2: An edge detection (horizontal Sobel) filter
# This matrix is built into skimage, but here it is manually defined
sobel_x_kernel = np.array([
    [-1, 0, 1],
    [-2, 0, 2],
    [-1, 0, 1]
])

# --- Apply the filter using scipy.ndimage.convolve ---

# Apply the sharpening filter
sharpened_image = scipy.ndimage.convolve(img_array, sharpening_kernel, mode='constant', cval=0.0)

# Apply the edge detection filter
edges_image = scipy.ndimage.convolve(img_array, sobel_x_kernel, mode='constant', cval=0.0)

# --- Display results (using matplotlib for visualization) ---
import matplotlib.pyplot as plt

plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
plt.imshow(img_array, cmap='gray')
plt.title("Original Grayscale Image")
plt.axis('off')

plt.subplot(1, 3, 2)
plt.imshow(sharpened_image, cmap='gray')
plt.title("Sharpened Image (Custom Filter)")
plt.axis('off')

plt.subplot(1, 3, 3)
plt.imshow(edges_image, cmap='gray')
plt.title("Edges (Custom Sobel Filter)")
plt.axis('off')

plt.show()